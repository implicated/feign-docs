<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Feign 的核心流程 :: Implicated</title>
    <link rel="canonical" href="https://docs.implicated.com/open-feign/feign/feign-core.html">
    <link rel="prev" href="feign-component.html">
    <link rel="next" href="../spring-cloud-open-feign/spring-feign-integrations.html">
    <meta name="generator" content="Antora 3.1.2">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://docs.implicated.com">Implicated</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
<!--    <div id="topbar-nav" class="navbar-menu">-->
<!--      <div class="navbar-end">-->
<!--        <a class="navbar-item" href="#">Home</a>-->
<!--        <div class="navbar-item has-dropdown is-hoverable">-->
<!--          <a class="navbar-link" href="#">Products</a>-->
<!--          <div class="navbar-dropdown">-->
<!--            <a class="navbar-item" href="#">Product A</a>-->
<!--            <a class="navbar-item" href="#">Product B</a>-->
<!--            <a class="navbar-item" href="#">Product C</a>-->
<!--          </div>-->
<!--        </div>-->
<!--        <div class="navbar-item has-dropdown is-hoverable">-->
<!--          <a class="navbar-link" href="#">Services</a>-->
<!--          <div class="navbar-dropdown">-->
<!--            <a class="navbar-item" href="#">Service A</a>-->
<!--            <a class="navbar-item" href="#">Service B</a>-->
<!--            <a class="navbar-item" href="#">Service C</a>-->
<!--          </div>-->
<!--        </div>-->
<!--        <div class="navbar-item">-->
<!--          <span class="control">-->
<!--            <a class="button is-primary" href="#">Download</a>-->
<!--          </span>-->
<!--        </div>-->
<!--      </div>-->
<!--    </div>-->
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="open-feign" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Learn OpenFeign</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../introduction.html">基本介绍</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Feign</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="feign-component.html">Feign 的组成</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="feign-core.html">Feign 的核心流程</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Spring Cloud Open Feign</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-cloud-open-feign/spring-feign-integrations.html">Spring 整合 Feign 原理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-cloud-open-feign/spring-mvc-support.html">SpringMVC 注解支持原理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-cloud-open-feign/spring-feign-configuration.html">Spring Cloud Open Feign 配置项</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../optimize.html">Open Feign 的性能优化</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../future.html">Feign 的未来</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ref.html">参考文档</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<!--<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Learn OpenFeign</span>
    <span class="version">default</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Learn OpenFeign</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">default</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
-->
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Learn OpenFeign</a></li>
    <li>Feign</li>
    <li><a href="feign-core.html">Feign 的核心流程</a></li>
  </ul>
</nav>
<!---->
<!--  -->
<!--  <div class="edit-this-page"><a href="https://github.com/implicated/feign-docs/edit/master/docs/modules/ROOT/pages/feign/feign-core.adoc">Edit this Page</a></div>-->
<!--  -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Feign 的核心流程</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>基本流程：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>JDK</code> 动态代理为每一个 <code>@FeignClient</code> 标记的接口生成代理类</p>
</li>
<li>
<p>生成代理类时为每个非默认方法添加了一个代理方法</p>
</li>
<li>
<p>最终执行代理类中的代理方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>核心类：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ReflectiveFeign</th>
<th class="tableblock halign-left valign-top">SynchronousMethodHandler</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="../_images/reflective-feign.png" alt="reflective feign">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="../_images/synchronous-method-handler.png" alt="synchronous method handler">
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="时序图"><a class="anchor" href="#时序图"></a>时序图</h2>
<div class="sectionbody">
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-29f3bdaafcbb966a39da13785aa4a604866303a9.svg" alt="Diagram">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="feign-的入口方法"><a class="anchor" href="#feign-的入口方法"></a>Feign 的入口方法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过Feign.builder()生成Feign.Builder的构造者对象，然后设置相关的参数，再调用target方法构造出动态代理。</p>
</div>
<div class="listingblock">
<div class="title">Feign.builder()</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Feign</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Builder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>();
  }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> {
      <span class="hljs-comment">//...</span>
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="构建-reflectfeign"><a class="anchor" href="#构建-reflectfeign"></a>构建 <code>ReflectFeign</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>target</code> 方法内部先调用 <code>build</code> 方法新建一个 <code>ReflectFeign</code> 对象，然后调用 <code>ReflectFeign</code> 的 <code>newInstance</code> 方法创建动态代理。</p>
</div>
<div class="listingblock">
<div class="title">feign.Feign</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">target</span><span class="hljs-params">(Target&lt;T&gt; target)</span> {
  <span class="hljs-comment">// spring-cloud-openfeign 注入最终执行方法，最后注入到 Spring 容器中的是接口的代理对象。</span>
  <span class="hljs-keyword">return</span> build().newInstance(target);
}

<span class="hljs-keyword">public</span> Feign <span class="hljs-title function_">build</span><span class="hljs-params">()</span> {
  <span class="hljs-comment">// 调用处理器工厂，设置属性</span>
  SynchronousMethodHandler.<span class="hljs-type">Factory</span> <span class="hljs-variable">synchronousMethodHandlerFactory</span> <span class="hljs-operator">=</span>
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousMethodHandler</span>.Factory(client, retryer, requestInterceptors, logger,
          logLevel, decode404, closeAfterDecode, propagationPolicy);
  <span class="hljs-comment">// 解析处理器handlersByName将所有参数进行封装，只有一个 apply 方法</span>
  <span class="hljs-type">ParseHandlersByName</span> <span class="hljs-variable">handlersByName</span> <span class="hljs-operator">=</span>
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseHandlersByName</span>(contract, options, encoder, decoder, queryMapEncoder,
          errorDecoder, synchronousMethodHandlerFactory);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveFeign</span>(
                    handlersByName,
                    <span class="hljs-comment">// InvocationHandlerFactory 控制反射方法的调度</span>
                    invocationHandlerFactory, <i class="conum" data-value="1"></i><b>(1)</b>
                    <span class="hljs-comment">// QueryMapEncoder 按照 name 和 value 转换 object 到 map</span>
                    queryMapEncoder); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Builder</code> 的属性，控制反射方法的调度，默认值是 <code>InvocationHandlerFactory.Default()</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Builder</code> 的属性，接口参数注解 <code>@QueryMap</code> 时，参数的编码器，默认值是 <code>QueryMapEncoder</code>.Default()</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="创建动态代理对象"><a class="anchor" href="#创建动态代理对象"></a>创建动态代理对象</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>ReflectiveFeign</code> 有五个内部类：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Inner Class</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FeignInvocationHandler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实现了 <code>java.lang.reflect.InvocationHandler</code>，定义 <code>JDK</code> 动态代理执行的方法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ParseHandlersByName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解析处理程序</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BuildTemplateByResolvingArgs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实现了 <code>RequestTemplate.Factory</code> ，<code>HTTP</code> 请求生成器工厂。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BuildEncodedTemplateFromArgs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">继承 <code>BuildTemplateByResolvingArgs</code>，重载 <code>resolve</code> 方法，解析 <code>body</code> 请求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BuildFormEncodedTemplateFromArgs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">继承 <code>BuildTemplateByResolvingArgs</code>，重载 <code>resolve</code> 方法，解析 <code>form</code> 表单请求。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>ReflectiveFeign.newInstance</code> 方法创建接口动态代理对象</p>
</div>
<div class="listingblock">
<div class="title">feign.ReflectiveFeign</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-comment">// 构造器</span>
ReflectiveFeign(ParseHandlersByName targetToHandlersByName,
                InvocationHandlerFactory factory,
                QueryMapEncoder queryMapEncoder) {
    <span class="hljs-built_in">this</span>.targetToHandlersByName = targetToHandlersByName;
    <span class="hljs-built_in">this</span>.factory = factory;
    <span class="hljs-built_in">this</span>.queryMapEncoder = queryMapEncoder;
}

<span class="hljs-comment">// 构造器</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Target&lt;T&gt; target)</span> {
    <span class="hljs-comment">// 1.解析方法元数据</span>
    <span class="hljs-comment">// targetToHandlersByName 是构造器传入的 ParseHandlersByName 对象</span>
    <span class="hljs-comment">// 根据 target 对象创建方法名和方法处理器的 map 映射</span>
    Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target); <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="hljs-comment">// 方法处理器的 map 映射</span>
    Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;Method, MethodHandler&gt;();
    <span class="hljs-comment">// 默认方法处理器的 map 映射</span>
    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;DefaultMethodHandler&gt;();

    <span class="hljs-comment">// target.type() is @FeignClient 标识的class</span>
    <span class="hljs-comment">// 遍历接口所有方法，构建 Method  -&gt;  MethodHandler 的映射</span>
    <span class="hljs-keyword">for</span> (Method method : target.type().getMethods()) {
        <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) {
            <span class="hljs-keyword">continue</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isDefault(method)) {
            <span class="hljs-comment">// 默认方法，执行原方法</span>
            <span class="hljs-type">DefaultMethodHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMethodHandler</span>(method);
            defaultMethodHandlers.add(handler);
            methodToHandler.put(method, handler);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 一般方法，执行代理类方法</span>
            methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));
        }
    }
    <span class="hljs-comment">// 2.设置调用处理器</span>
    <span class="hljs-comment">// 创建动态代理，factory 是 InvocationHandlerFactory.Default，创建出来的是</span>
    <span class="hljs-comment">// feign.ReflectiveFeign.FeignInvocationHandler.dispatch 持有 methodToHandler 引用</span>
    <span class="hljs-comment">// ReflectiveFeign.FeignInvocationHandler，也就是说后续对方法的调用都会进入到该对象的 invoke 方法</span>
    <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> factory.create(target, methodToHandler); <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="hljs-comment">// 3.生成 JDK 动态代理</span>
    <span class="hljs-type">T</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(), <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]{target.type()}, handler);

    <span class="hljs-comment">// 绑定默认方法到代理上</span>
    <span class="hljs-keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {
        defaultMethodHandler.bindTo(proxy);
    }
    <span class="hljs-keyword">return</span> proxy;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="#_method-handler">根据指定的 contract 解析 target，根据 MethodMetadata 生成 MethodHandler 。</a>
<details>
<summary class="title">方法元数据</summary>
<div class="content">
<div class="imageblock">
<div class="content">
<img src="../_images/name-to-hander.png" alt="name to hander">
</div>
</div>
</div>
</details></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="#_invocation-handler">设置调用处理器，最终执行 HTTP 请求的地方。</a>
<details>
<summary class="title">调用处理器</summary>
<div class="content">
<div class="imageblock">
<div class="content">
<img src="../_images/invocatio-handler.png" alt="invocatio handler">
</div>
</div>
</div>
</details></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>生成 <code>JDK</code> 动态代理。
<details>
<summary class="title">动态代理</summary>
<div class="content">
<div class="imageblock">
<div class="content">
<img src="../_images/proxy-1.png" alt="proxy 1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/proxy-2.png" alt="proxy 2">
</div>
</div>
</div>
</details></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_method-handler"><a class="anchor" href="#_method-handler"></a>解析方法元数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Spring-cloud</code> 继承 <code>Contract.BaseContract</code>，实现处理参数的方法</p>
</div>
<details>
<summary class="title">查看 <code>BaseContract</code> 类图</summary>
<div class="content">
<div class="imageblock">
<div class="content">
<img src="../_images/base-contract.png" alt="base contract">
</div>
</div>
</div>
</details>
<div class="listingblock">
<div class="title">feign.ReflectiveFeign.ParseHandlersByName#apply</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(Target key)</span> {
    <span class="hljs-comment">// 待处理的方法元数据</span>
    List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type()); <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="hljs-comment">// 保存生成的方法处理器</span>
    Map&lt;String, MethodHandler&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, MethodHandler&gt;();
    <span class="hljs-comment">// 处理方法元数据</span>
    <span class="hljs-keyword">for</span> (MethodMetadata md : metadata) {
        BuildTemplateByResolvingArgs buildTemplate;
        <span class="hljs-comment">// form 表单</span>
        <span class="hljs-keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="hljs-literal">null</span>) {
            buildTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildFormEncodedTemplateFromArgs</span>(md, encoder, queryMapEncoder);
        }
        <span class="hljs-comment">// body</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (md.bodyIndex() != <span class="hljs-literal">null</span>) {
            buildTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildEncodedTemplateFromArgs</span>(md, encoder, queryMapEncoder);
        }
        <span class="hljs-comment">// 其它请求</span>
        <span class="hljs-keyword">else</span> {
            buildTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildTemplateByResolvingArgs</span>(md, queryMapEncoder);
        }
        <span class="hljs-comment">// 创建方法处理器</span>
        result.put(md.configKey(),
                factory.create(key, md, buildTemplate, options, decoder, errorDecoder)); <i class="conum" data-value="2"></i><b>(2)</b>
    }
    <span class="hljs-keyword">return</span> result;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>获取方法元数据</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>为每个方法创建自己的方法处理器</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="获取方法元数据"><a class="anchor" href="#获取方法元数据"></a>获取方法元数据</h3>
<div class="paragraph">
<p>解析每个非默认方法获取方法元数据。</p>
</div>
<div class="listingblock">
<div class="title">feign.Contract.BaseContract#parseAndValidatateMetadata</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> List&lt;MethodMetadata&gt; <span class="hljs-title function_">parseAndValidatateMetadata</span><span class="hljs-params">(Class&lt;?&gt; targetType)</span> {
    <span class="hljs-comment">//...</span>

    <span class="hljs-comment">// 解析每个方法</span>
    Map&lt;String, MethodMetadata&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, MethodMetadata&gt;();
    <span class="hljs-keyword">for</span> (Method method : targetType.getMethods()) {
        <span class="hljs-comment">// 跳过默认方法</span>
        <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class ||
                (method.getModifiers() &amp; Modifier.STATIC) != <span class="hljs-number">0</span> ||
                Util.isDefault(method)) {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-comment">// 解析方法元数据，进入 SpringMvcContract</span>
        <span class="hljs-type">MethodMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> parseAndValidateMetadata(targetType, method);
        checkState(!result.containsKey(metadata.configKey()), <span class="hljs-string">&quot;Overrides unsupported: %s&quot;</span>,
                metadata.configKey());
        result.put(metadata.configKey(), metadata);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(result.values());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析每个具体方法。</p>
</div>
<div class="listingblock">
<div class="title">feign.Contract.BaseContract#parseAndValidateMetadata</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">protected</span> MethodMetadata <span class="hljs-title function_">parseAndValidateMetadata</span><span class="hljs-params">(Class&lt;?&gt; targetType, Method method)</span> {
    <span class="hljs-type">MethodMetadata</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodMetadata</span>();
    data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));
    <span class="hljs-comment">// 方法唯一key</span>
    data.configKey(Feign.configKey(targetType, method));

    <span class="hljs-comment">// 解析class上注解</span>
    <span class="hljs-keyword">if</span> (targetType.getInterfaces().length == <span class="hljs-number">1</span>) {
        processAnnotationOnClass(data, targetType.getInterfaces()[<span class="hljs-number">0</span>]);
    }
    processAnnotationOnClass(data, targetType);


    <span class="hljs-comment">// 解析method上注解</span>
    <span class="hljs-keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) {
        processAnnotationOnMethod(data, methodAnnotation, method);
    }
    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
    Type[] genericParameterTypes = method.getGenericParameterTypes();

    <span class="hljs-comment">// 解析参数</span>
    Annotation[][] parameterAnnotations = method.getParameterAnnotations();
    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> parameterAnnotations.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) {
        <span class="hljs-type">boolean</span> <span class="hljs-variable">isHttpAnnotation</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (parameterAnnotations[i] != <span class="hljs-literal">null</span>) {
            isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);
        }
        <span class="hljs-keyword">if</span> (parameterTypes[i] == URI.class) {
            data.urlIndex(i);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isHttpAnnotation &amp;&amp; parameterTypes[i] != Request.Options.class) {
            data.bodyIndex(i);
            data.bodyType(Types.resolve(targetType, targetType, genericParameterTypes[i]));
        }
    }
    <span class="hljs-keyword">return</span> data;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="创建方法处理器"><a class="anchor" href="#创建方法处理器"></a>创建方法处理器</h3>
<div class="listingblock">
<div class="title">feign.SynchronousMethodHandler.Factory#create</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">public</span> MethodHandler <span class="hljs-title function_">create</span><span class="hljs-params">(Target&lt;?&gt; target,
                            MethodMetadata md,
                            RequestTemplate.Factory buildTemplateFromArgs,
                            Options options,
                            Decoder decoder,
                            ErrorDecoder errorDecoder)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousMethodHandler</span>(target, client, retryer, requestInterceptors, logger,
            logLevel, md, buildTemplateFromArgs, options, decoder,
            errorDecoder, decode404, closeAfterDecode, propagationPolicy);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_invocation-handler"><a class="anchor" href="#_invocation-handler"></a>设置调用处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过工厂方法生成调用处理器。</p>
</div>
<div class="listingblock">
<div class="title">feign.InvocationHandlerFactory.Default</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Default</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandlerFactory</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> InvocationHandler <span class="hljs-title function_">create</span><span class="hljs-params">(Target target, Map&lt;Method, MethodHandler&gt; dispatch)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveFeign</span>.FeignInvocationHandler(target, dispatch);
    }
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="不同方法的路由"><a class="anchor" href="#不同方法的路由"></a>不同方法的路由</h3>
<div class="paragraph">
<p><code>MethodHandler</code> 有两个实现，<code>DefaultMethodHandler</code> 和 <code>SynchronousMethodHandler</code>。 默认方法走 <code>DefaultMethodHandler</code> ，其它方法走 <code>SynchronousMethodHandler</code>。</p>
</div>
<div class="listingblock">
<div class="title">feign.ReflectiveFeign.FeignInvocationHandler#invoke</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable {
    <span class="hljs-comment">// 自定义equals、hashCode和toString方法的处理</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;equals&quot;</span>.equals(method.getName())) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Object</span> <span class="hljs-variable">otherHandler</span> <span class="hljs-operator">=</span>
                    args.length &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span> ? Proxy.getInvocationHandler(args[<span class="hljs-number">0</span>]) : <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span> equals(otherHandler);
        } <span class="hljs-keyword">catch</span> (IllegalArgumentException e) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;hashCode&quot;</span>.equals(method.getName())) {
        <span class="hljs-keyword">return</span> hashCode();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;toString&quot;</span>.equals(method.getName())) {
        <span class="hljs-keyword">return</span> toString();
    }

    <span class="hljs-comment">// dispatch 就是 newInstance 方法中的 methodToHandler</span>
    <span class="hljs-keyword">return</span> dispatch.get(method).invoke(args);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defaultmethodhandler"><a class="anchor" href="#defaultmethodhandler"></a><code>DefaultMethodHandler</code></h3>
<div class="paragraph">
<p>执行代理接口自己的方法。</p>
</div>
<div class="listingblock">
<div class="title">feign.DefaultMethodHandler#invoke</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object[] argv)</span> <span class="hljs-keyword">throws</span> Throwable {
    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(
                <span class="hljs-string">&quot;Default method handler invoked before proxy has been bound.&quot;</span>);
    }
    <span class="hljs-keyword">return</span> handle.invokeWithArguments(argv);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="synchronousmethodhandler"><a class="anchor" href="#synchronousmethodhandler"></a><code>SynchronousMethodHandler</code></h3>
<div class="paragraph">
<p>定义了发起 HTTP 请求的方法</p>
</div>
<div class="listingblock">
<div class="title">feign.SynchronousMethodHandler#invoke</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object[] argv)</span> <span class="hljs-keyword">throws</span> Throwable {
    <span class="hljs-comment">// RequestTemplate 定义了完整的HTTP请求信息</span>
    <span class="hljs-type">RequestTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> buildTemplateFromArgs.create(argv);
    <span class="hljs-comment">// Options 定义了连接超时时间、请求超时时间、是否允许重定向</span>
    <span class="hljs-type">Options</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> findOptions(argv);
    <span class="hljs-comment">// 重试设置</span>
    <span class="hljs-type">Retryer</span> <span class="hljs-variable">retryer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.retryer.clone();
    <span class="hljs-comment">// 成功返回，失败抛异常</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行和解码</span>
            <span class="hljs-keyword">return</span> executeAndDecode(template, options);
        } <span class="hljs-keyword">catch</span> (RetryableException e) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 判断是否继续重试</span>
                retryer.continueOrPropagate(e);
            } <span class="hljs-keyword">catch</span> (RetryableException th) {
                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> th.getCause();
                <span class="hljs-keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">throw</span> cause;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">throw</span> th;
                }
            }
            <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) {
                logger.logRetry(metadata.configKey(), logLevel);
            }
            <span class="hljs-comment">// 重试</span>
            <span class="hljs-keyword">continue</span>;
        }
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="发起请求和解析响应"><a class="anchor" href="#发起请求和解析响应"></a>发起请求和解析响应</h4>
<div class="listingblock">
<div class="title">feign.SynchronousMethodHandler#executeAndDecode</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Object <span class="hljs-title function_">executeAndDecode</span><span class="hljs-params">(RequestTemplate template, Options options)</span> <span class="hljs-keyword">throws</span> Throwable {
    <span class="hljs-comment">// RequestTemplate 转换为 Request</span>
    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> targetRequest(template);

    <span class="hljs-comment">// 打印请求参数</span>
    <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) {
        logger.logRequest(metadata.configKey(), logLevel, request);
    }

    <span class="hljs-comment">// 打印接口响应时间</span>
    Response response;
    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 发起请求</span>
        response = client.execute(request, options);
    } <span class="hljs-keyword">catch</span> (IOException e) {
        <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) {
            logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));
        }
        <span class="hljs-comment">// 抛出重试异常 RetryableException()</span>
        <span class="hljs-keyword">throw</span> errorExecuting(request, e);
    }
    <span class="hljs-type">long</span> <span class="hljs-variable">elapsedTime</span> <span class="hljs-operator">=</span> TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);

    <span class="hljs-type">boolean</span> <span class="hljs-variable">shouldClose</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) {
            response =
                    logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);
        }
        <span class="hljs-keyword">if</span> (Response.class == metadata.returnType()) {
            <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> response;
            }
            <span class="hljs-keyword">if</span> (response.body().length() == <span class="hljs-literal">null</span> ||
                    response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) {
                shouldClose = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">return</span> response;
            }
            <span class="hljs-comment">// Ensure the response body is disconnected</span>
            <span class="hljs-comment">// 读取body字节数组，返回response</span>
            <span class="hljs-type">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());
            <span class="hljs-keyword">return</span> response.toBuilder().body(bodyData).build();
        }
        <span class="hljs-comment">// 处理 2XX</span>
        <span class="hljs-keyword">if</span> (response.status() &gt;= <span class="hljs-number">200</span> &amp;&amp; response.status() &lt; <span class="hljs-number">300</span>) {
            <span class="hljs-comment">// 接口返回void</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">void</span>.class == metadata.returnType()) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
            <span class="hljs-comment">// 解码response，直接调用decoder解码</span>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> decode(response);
                shouldClose = closeAfterDecode;
                <span class="hljs-keyword">return</span> result;
            }
        }
        <span class="hljs-comment">// 处理 404</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="hljs-number">404</span> &amp;&amp; <span class="hljs-keyword">void</span>.class != metadata.returnType()) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> decode(response);
            shouldClose = closeAfterDecode;
            <span class="hljs-keyword">return</span> result;
        }
        <span class="hljs-comment">// 其他返回码，使用errorDecoder解析，抛出异常</span>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);
        }
    } <span class="hljs-keyword">catch</span> (IOException e) {
        <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) {
            logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);
        }
        <span class="hljs-keyword">throw</span> errorReading(request, response, e);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (shouldClose) {
            <span class="hljs-comment">// 关流</span>
            ensureClosed(response.body());
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="发送http请求"><a class="anchor" href="#发送http请求"></a>发送HTTP请求</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>feign.Client</code> 是一个接口，默认实现类是 <code>feign.Client.Default</code>， 使用 <code>java.net.HttpURLConnection</code> 发送 <code>HTTP</code> 请求。</p>
</div>
<div class="paragraph">
<p>feign还实现了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ApacheHttpClient</p>
</li>
<li>
<p>OkHttpClient</p>
</li>
<li>
<p>RibbonClient</p>
</li>
<li>
<p>Java 11 Http2</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="默认请求方式"><a class="anchor" href="#默认请求方式"></a>默认请求方式。</h3>
<div class="listingblock">
<div class="title">feign.Client.Default#execute</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Response <span class="hljs-title function_">execute</span><span class="hljs-params">(Request request, Options options)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> convertAndSend(request, options); <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="hljs-keyword">return</span> convertResponse(connection, request); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>发送请求</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>解析响应</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="发送请求"><a class="anchor" href="#发送请求"></a>发送请求</h4>
<div class="listingblock">
<div class="title">feign.Client.Default#convertAndSend</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpURLConnection <span class="hljs-title function_">convertAndSend</span><span class="hljs-params">(Request request, Options options)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(request.url());
    <span class="hljs-comment">// 获取 conniption</span>
    <span class="hljs-keyword">final</span> <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getConnection(url);
    <span class="hljs-comment">//...</span>

    connection.setConnectTimeout(options.connectTimeoutMillis());
    connection.setReadTimeout(options.readTimeoutMillis());
    connection.setAllowUserInteraction(<span class="hljs-literal">false</span>);
    connection.setInstanceFollowRedirects(options.isFollowRedirects());
    connection.setRequestMethod(request.httpMethod().name());

    <span class="hljs-comment">//..</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="解析响应"><a class="anchor" href="#解析响应"></a>解析响应</h4>
<div class="listingblock">
<div class="title">feign.Client.Default#convertResponse</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Response <span class="hljs-title function_">convertResponse</span><span class="hljs-params">(HttpURLConnection connection, Request request)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> connection.getResponseCode();
    <span class="hljs-type">String</span> <span class="hljs-variable">reason</span> <span class="hljs-operator">=</span> connection.getResponseMessage();

    <span class="hljs-keyword">if</span> (status &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(format(<span class="hljs-string">&quot;Invalid status(%s) executing %s %s&quot;</span>, status,
                connection.getRequestMethod(), connection.getURL()));
    }

    Map&lt;String, Collection&lt;String&gt;&gt; headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; field : connection.getHeaderFields().entrySet()) {
        <span class="hljs-comment">// response message</span>
        <span class="hljs-keyword">if</span> (field.getKey() != <span class="hljs-literal">null</span>) {
            headers.put(field.getKey(), field.getValue());
        }
    }

    <span class="hljs-type">Integer</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> connection.getContentLength();
    <span class="hljs-keyword">if</span> (length == -<span class="hljs-number">1</span>) {
        length = <span class="hljs-literal">null</span>;
    }
    InputStream stream;
    <span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">400</span>) {
        stream = connection.getErrorStream();
    } <span class="hljs-keyword">else</span> {
        stream = connection.getInputStream();
    }
    <span class="hljs-keyword">return</span> Response.builder()
            .status(status)
            .reason(reason)
            .headers(headers)
            .request(request)
            .body(stream, length)
            .build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apache-httpclient"><a class="anchor" href="#apache-httpclient"></a><code>Apache HttpClient</code></h3>
<div class="paragraph">
<p>To Be Continued.</p>
</div>
</div>
<div class="sect2">
<h3 id="okhttp"><a class="anchor" href="#okhttp"></a><code>OkHttp</code></h3>
<div class="paragraph">
<p>To Be Continued.</p>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="feign-component.html">Feign 的组成</a></span>
  <span class="next"><a href="../spring-cloud-open-feign/spring-feign-integrations.html">Spring 整合 Feign 原理</a></span>
</nav>
</article>
  </div>
</main>
</div>
<!--<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
-->
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
  </body>
</html>
